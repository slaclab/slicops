import { encode, decode } from '@msgpack/msgpack';
import { logService } from '@/services/log.js';

//TODO(robnagler) needs to be generated by server
const AUTH_API_NAME = 'authenticate_connection';
const AUTH_API_VERSION = 658584001;

const MSG_KIND_BASE = 777500;
const MSG_KIND_CALL = 1 + MSG_KIND_BASE;
const MSG_KIND_REPLY = 2 + MSG_KIND_BASE;
const MSG_KIND_SUBSCRIBE = 3 + MSG_KIND_BASE;
const MSG_KIND_UNSUBSCRIBE = 4 + MSG_KIND_BASE;


class Call {
    destroyed = false;

    // not a public interface
    constructor(apiService, log, isSubscription, call_id, api_name, api_args, resultHandler, apiErrorHandler) {
        this.apiErrorHandler = apiErrorHandler;
        this.apiService = apiService;
        this.api_args = api_args;
        this.api_name = api_name;
        this.call_id = call_id;
        this.isSubscription = isSubscription;
        this.log = log;
        this.resultHandler = resultHandler;
    }

    // Stop a subscription
    unsubscribe() {
        if (this.destroyed) {
            // so unsubscribe() can be idempotent
            return;
        }
        if (! this.isSubscription) {
            throw new Error(`call to api_name=${this.api_name} is not a subscription`);
        }
        this.apiService.sendUnsubscribe(
            encode({
                call_id: this.call_id,
                msg_kind: MSG_KIND_UNSUBSCRIBE,
            }),
        );
        this.destroy();
    }

    // not a public interface
    destroy() {
        if (this.destroyed) {
            return;
        }
        this.destroyed = true;
        this.apiService.callDestroy(this.call_id);
    }

    // not a public interface
    handleError(api_error) {
        if (this.apiErrorHandler) {
            this.apiErrorHandler(api_error);
        }
        else {
            //TODO(robnagler) need to make this user visible
            this.log.error(['call error', api_error, this]);
        }
        // implicit unsubscribe
        this.destroy();
    }

    // not a public interface
    handleResult(api_result) {
        this.resultHandler(api_result);
        if (api_result == null || ! this.isSubscription) {
            this.destroy();
        }
    }

    // not a public interface
    msg() {
        const a = this.api_args;
        this.api_args = null;
        return encode({
            api_args: a,
            api_name: this.api_name,
            call_id: this.call_id,
            msg_kind: this.isSubscription ? MSG_KIND_SUBSCRIBE : MSG_KIND_CALL,
        });
    }
}


class APIService {
    #authOK = false;
    #call_id = 0;
    #client_id = null;
    //TODO(robnagler) registration interface
    #pendingCalls = new Map();
    #socket = null;
    #socketRetryBackoff = 0;
    #unsentMsgs = [];

    constructor(log) {
        this.log = log;
        this.log.info('create websocket');
        this.#socketOpen();
    }

    // Single send and a reply
    call(api_name, api_args, resultHandler, apiErrorHandler) {
        return this.#sendCall(new Call(this, this.log, false, ++this.#call_id, api_name, api_args, resultHandler, apiErrorHandler));
    }

    // not a public interface
    callDestroy(call_id) {
        this.#pendingCalls.delete(call_id);
        // unsentMsgs could be deleted, but unlikely
    }

    onDestroy() {
        this.log.info('destroy websocket');
        if (this.#socket) {
            this.#socket.close();
            this.#socket = null;
        }
        this.#clearCalls('onDestroy');
    }

    // not a public interface
    sendUnsubscribe(msg) {
        this.#unsentMsgs.push(msg);
        this.#send();
    }

    // Single send and a reply
    subscribe(api_name, api_args, resultHandler, apiErrorHandler) {
        return this.#sendCall(new Call(this, this.log, true, ++this.#call_id, api_name, api_args, resultHandler, apiErrorHandler));
    }

    #authError(error) {
        // If there is a protocol error, this will retry forever. That would be a major problem
        // which is not fixable or really detectable. Likely case is the socket closed before auth
        // completed.
        if (this.#socket) {
            this.#socket.close();
        }
        this.#socketOnError(error);
    }

    #authResult(api_result) {
        this.#authOK = true;
        this.#socketRetryBackoff = 0;
        this.#send();
    }

    #clearCalls(error) {
        const a = [...this.#pendingCalls.values()];
        this.#pendingCalls = new Map();
        this.#unsentMsgs = [];
        for (const c of a) {
            c.destroy();
        }
    }

    #findCall(calls, call_id) {
        const rv = calls.get(call_id);
        if (! rv) {
            return null;
        }
        if (rv.destroyed) {
            // TODO(robnagler) raise error? This should not happen.
            calls.delete(call_id);
            return null;
        }
        return rv;
    }

    #send() {
        if (! this.#socket || this.#unsentMsgs.length <= 0 || ! this.#authOK) {
            return;
        }
        let m = null;
        while (m = this.#unsentMsgs.shift()) {
            this.#sendOne(m);
        }
    };

    #sendCall(call) {
        this.#pendingCalls.set(call.call_id, call);
        this.#unsentMsgs.push(call.msg());
        this.#send();
        return call;
    }

    #sendOne(msg) {
        if (! this.#socket) {
            return;
        }
        this.#socket.send(msg);
    }

    #socketOnError(event) {
        // close: event.code : short, event.reason : str, wasClean : boolean
        // error: app specific
        this.#socket = null;
        if (this.#socketRetryBackoff <= 0) {
            this.#socketRetryBackoff = 1;
            this.log.error(['WebSocket failed', event]);
            this.#clearCalls(event.wasClean ? 'socket closed' : 'socket error');
        }
        if (this.#socketRetryBackoff < 60) {
            this.#socketRetryBackoff *= 2;
        }
        setTimeout(this.#socketOpen.bind(this), this.#socketRetryBackoff * 1000);
    };

    #socketOnMessage(msg) {
        // Msg = {
        //     call_id: number;
        //     msg_kind: number;
        //     api_error?: string;
        //     api_result?: any;
        // }
        const m = decode(msg);
        const c = this.#findCall(this.#pendingCalls, m.call_id);
        if (! c) {
            // happens on unsubscribe
            return;
        }
        if (MSG_KIND_REPLY == m.msg_kind) {
            if (m.api_error) {
                c.handleError(m.api_error);
            }
            else {
                c.handleResult(m.api_result);
            }
        }
        else if (MSG_KIND_UNSUBSCRIBE == m.msg_kind) {
            if (c.isSubscription) {
                c.handleResult(null);
            }
            else {
                c.handleError('unsubscribe of non-subscription');
            }
        }
        else {
            c.handleError(`protocol error: invalid msg_kind=${m.msg_kind}`)
        }
    };

    #socketOnOpen(event) {
        // throw new Error("not open");
        this.call(
            AUTH_API_NAME,
            {
                // No token, because any value would have to come from the server,
                // and therefore would be discoverable.
                token: null,
                version: AUTH_API_VERSION,
            },
            this.#authResult.bind(this),
            this.#authError.bind(this),
        )
        const m = this.#unsentMsgs.pop();
        this.#sendOne(m);
    };

    #socketOpen() {
        try {
            const s = new WebSocket('/api-v1')
            s.onclose = this.#socketOnError.bind(this);
            s.onerror = this.#socketOnError.bind(this);
            s.onmessage = (event) => {
                this.#socketOnMessage.bind(this);
                event.data.arrayBuffer().then(
                    this.#socketOnMessage.bind(this),
                    (error) => {
                        this.log.error(['arrayBuffer decode error', error, event.data]);
                        this.#socketOnError(event);
                    },
                );
            };
            s.onopen = this.#socketOnOpen.bind(this);
            this.#authOK = false;
            this.#socket = s;
        } catch (err) {
            this.#socketOnError(err);
        }
    };
}

export const apiService = new APIService(logService);
//TODO(pjm): this doesn't get called on dev during auto page refresh, only on manual browser refresh
window.addEventListener('beforeunload', (event) => {
    apiService.onDestroy();
});
