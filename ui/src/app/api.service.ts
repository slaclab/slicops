// Interface to UI API service
//
// Copyright (c) 2024 The Board of Trustees of the Leland Stanford Junior University, through SLAC National Accelerator Laboratory (subject to receipt of any required approvals from the U.S. Dept. of Energy).  All Rights Reserved.
// http://github.com/slaclab/slicops/LICENSE

import { Injectable } from '@angular/core';
import { encode, decode } from '@msgpack/msgpack';
import { LogService } from './log.service';

type ResultHandler = (api_result: any) => void;

type APIErrorHandler = (api_error: string) => void;

type ReplyMsg = {
    api_error: string;
    call_id: number;
    api_result: any;
};

//TODO(robnagler) needs to be generated by server
const AUTH_API_NAME = 'authenticate_connection';

const AUTH_API_VERSION = 658584001;

const MSG_KIND_BASE = 777500;
const MSG_KIND_CALL = 1 + MSG_KIND_BASE;
const MSG_KIND_REPLY = 2 + MSG_KIND_BASE;
const MSG_KIND_SUBSCRIBE = 3 + MSG_KIND_BASE;
const MSG_KIND_UNSUBSCRIBE = 4 + MSG_KIND_BASE;


class Call {
    call_id: number;
    api_name: string;
    resultHandler: ResultHandler;
    destroyed: boolean = false;
    msg: any;
    apiErrorHandler?: APIErrorHandler;

    constructor(call_id: number, api_name: string, api_args: any, resultHandler: ResultHandler, apiErrorHandler?: APIErrorHandler) {
        this.call_id = call_id;
        this.api_name = api_name;
        this.resultHandler = resultHandler;
        this.apiErrorHandler = apiErrorHandler;
        this.msg = encode({
            call_id: call_id,
            msg_kind: MSG_KIND_CALL,
            api_name: api_name,
            api_args: api_args,
        });
    }

    destroy() {
        this.destroyed = true;
    }

    handleResult(api_result: any) {
        this.resultHandler(api_result);
        this.destroy();
    }
}

@Injectable({
    providedIn: 'root'
})
export class APIService {
    #authOK: boolean = false;
    #call_id: number = 0;
    #client_id: string | null = null;
    //TODO(robnagler) registration interface
    #errorHandler = this.#defaultErrorHandler;
    #pendingCalls: Map<number, Call> = new Map<number,Call>();
    #socket: WebSocket | null = null;
    #socketRetryBackoff: number = 0;
    #unsentCalls: Array<Call> = new Array<Call>;

    constructor(private log: LogService) {
        this.log.info('create websocket');
        this.#socketOpen();
    }

    // Send a message to the server
    call(api_name: string, api_args: any, resultHandler: ResultHandler, apiErrorHandler?: APIErrorHandler) : Call {
        const rv = new Call(++this.#call_id, api_name, api_args, resultHandler, apiErrorHandler);
        this.#unsentCalls.push(rv);
        this.#send();
        return rv;
    }

    ngOnDestroy() {
        this.log.info('destroy websocket');
        if (this.#socket) {
            this.#socket.close();
            this.#socket = null;
        }
        this.#clearCalls('ngOnDestroy');
    }

    #authError(error: string) {
        // If there is a protocol error, this will retry forever. That would be a major problem
        // which is not fixable or really detectable. Likely case is the socket closed before auth
        // completed.
        if (this.#socket) {
            this.#socket.close();
        }
        this.#socketOnError(error);
    }

    #authResult(api_result: any) {
        this.#authOK = true;
        this.#socketRetryBackoff = 0;
        this.#send();
    }

    #clearCalls(error: string) {
        const a = [...this.#pendingCalls.values(), ...this.#unsentCalls];
        this.#pendingCalls = new Map<number,Call>();
        this.#unsentCalls = new Array<Call>();
        for (const c of a) {
            if (c.destroyed) {
                continue;
            }
            if (c.apiErrorHandler) {
                c.apiErrorHandler(error);
            }
            c.destroy();
        }
    }


    #defaultErrorHandler(error: any, call?: Call) {
        const m = ['error', error];
        if (call) {
            m.push(call.call_id, call.api_name);
        }
        this.log.error(m);
    }

    #findCall(calls: Map<number, Call>, call_id: number) : Call | null {
        const rv = calls.get(call_id);
        if (! rv) {
            return null;
        }
        calls.delete(call_id);
        if (rv.destroyed) {
            return null;
        }
        return rv;
    }

    #send() {
        if (! this.#socket || this.#unsentCalls.length <= 0 || ! this.#authOK) {
            return;
        }
        let c = null;
        while (c = this.#unsentCalls.shift()) {
            this.#sendOne(c);
        }
    };

    #sendOne(call: Call) {
        // the latter test is to pacify typescript
        if (call.destroyed || ! this.#socket) {
            return;
        }
        this.log.dbg(['call', call.call_id, call.api_name]);
        this.#pendingCalls.set(call.call_id, call);
        this.#socket.send(call.msg);
    }

    #socketOnError(event: any) {
        // close: event.code : short, event.reason : str, wasClean : bool
        // error: app specific
        this.#socket = null;
        if (this.#socketRetryBackoff <= 0) {
            this.#socketRetryBackoff = 1;
            this.#errorHandler(['WebSocket failed', event]);
            this.#clearCalls(event.wasClean ? 'socket closed' : 'socket error');
        }
        if (this.#socketRetryBackoff < 60) {
            this.#socketRetryBackoff *= 2;
        }
        this.log.dbg(['socketRetryBackoff', this.#socketRetryBackoff]);
        setTimeout(this.#socketOpen.bind(this), this.#socketRetryBackoff * 1000);
    };

    #socketOnMessage(msg: any) {
        const m = decode(msg) as ReplyMsg;
        const c = this.#findCall(this.#pendingCalls, m.call_id);
        if (! c) {
            this.log.error(['call not found, ignoring', m.call_id])
            return;
        }
        if (m.api_error) {
            if (c.apiErrorHandler) {
                c.apiErrorHandler(m.api_error);
            }
            else {
                this.log.dbg(['api_error calling errorHandler', m.api_error, c.api_name, c.call_id]);
                this.#errorHandler(m.api_error, c);
            }
            c.destroy();
        }
        else {
            this.log.dbg(['api_result', m.api_result, c.api_name, c.call_id]);
            c.handleResult(m.api_result);
        }
    };

    #socketOnOpen(event: Event) {
        // throw new Error("not open");
        this.call(
            AUTH_API_NAME,
            {
                // No token, because any value would have to come from the server,
                // and therefore would be discoverable.
                token: null,
                version: AUTH_API_VERSION,
            },
            this.#authResult.bind(this),
            this.#authError.bind(this),
        )
        const c = this.#unsentCalls.pop()!;
        this.#sendOne(c);
    };

    #socketOpen() {
        try {
            const s = new WebSocket('/api-v1')
            s.onclose = this.#socketOnError.bind(this);
            s.onerror = this.#socketOnError.bind(this);
            s.onmessage = (event) => {
                this.#socketOnMessage.bind(this);
                event.data.arrayBuffer().then(
                    this.#socketOnMessage.bind(this),
                    (error: Event) => {
                        this.log.error(['arrayBuffer decode error', error, event.data]);
                        this.#socketOnError(event);
                    },
                );
            };
            s.onopen = this.#socketOnOpen.bind(this);
            this.#authOK = false;
            this.#socket = s;
        } catch (err) {
            this.#socketOnError(err);
        }
    };
}
