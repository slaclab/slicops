// Interface to UI API service
//
// Copyright (c) 2024 The Board of Trustees of the Leland Stanford Junior University, through SLAC National Accelerator Laboratory (subject to receipt of any required approvals from the U.S. Dept. of Energy).  All Rights Reserved.
// http://github.com/slaclab/slicops/LICENSE

import { Injectable } from '@angular/core';
import { encode, decode } from '@msgpack/msgpack';
import { LogService } from './log.service';

type ResultHandler = (api_result: any) => void;

type APIErrorHandler = (api_error: string) => void;

type Msg = {
    call_id: number;
    msg_kind: number;
    api_error?: string;
    api_result?: any;
};

//TODO(robnagler) needs to be generated by server
const AUTH_API_NAME = 'authenticate_connection';

const AUTH_API_VERSION = 658584001;

const MSG_KIND_BASE = 777500;
const MSG_KIND_CALL = 1 + MSG_KIND_BASE;
const MSG_KIND_REPLY = 2 + MSG_KIND_BASE;
const MSG_KIND_SUBSCRIBE = 3 + MSG_KIND_BASE;
const MSG_KIND_UNSUBSCRIBE = 4 + MSG_KIND_BASE;


class Call {
    apiErrorHandler?: APIErrorHandler;
    apiService: APIService;
    api_args: any;
    api_name: string;
    call_id: number;
    destroyed: boolean = false;
    isSubscription: boolean;
    log: LogService;
    resultHandler: ResultHandler;

    // not a public interface
    constructor(apiService: APIService, log: LogService, isSubscription: boolean, call_id: number, api_name: string, api_args: any, resultHandler: ResultHandler, apiErrorHandler?: APIErrorHandler) {
        this.apiErrorHandler = apiErrorHandler;
        this.apiService = apiService;
        this.api_args = api_args;
        this.api_name = api_name;
        this.call_id = call_id;
        this.isSubscription = isSubscription;
        this.log = log;
        this.resultHandler = resultHandler;
    }

    // Stop a subscription
    unsubscribe() {
        if (this.destroyed) {
            // so unsubscribe() can be idempotent
            return;
        }
        if (! this.isSubscription) {
            throw new Error(`call to api_name=${this.api_name} is not a subscription`);
        }
        this.apiService.sendUnsubscribe(
            encode({
                call_id: this.call_id,
                msg_kind: MSG_KIND_UNSUBSCRIBE,
            }),
        );
        this.destroy();
    }

    // not a public interface
    destroy() {
        if (this.destroyed) {
            return;
        }
        this.destroyed = true;
        this.apiService.callDestroy(this.call_id);
    }

    // not a public interface
    handleError(api_error: any) {
        if (this.apiErrorHandler) {
            this.apiErrorHandler(api_error);
        }
        else {
            //TODO(robnagler) need to make this user visible
            this.log.error(['call error', api_error, this]);
        }
        // implicit unsubscribe
        this.destroy();
    }

    // not a public interface
    handleResult(api_result: any) {
        this.resultHandler(api_result);
        if (api_result == null || ! this.isSubscription) {
            this.destroy();
        }
    }

    // not a public interface
    msg() : any {
        const a = this.api_args;
        this.api_args = null;
        return encode({
            api_args: a,
            api_name: this.api_name,
            call_id: this.call_id,
            msg_kind: this.isSubscription ? MSG_KIND_SUBSCRIBE : MSG_KIND_CALL,
        });
    }
}

@Injectable({
    providedIn: 'root'
})
export class APIService {
    #authOK: boolean = false;
    #call_id: number = 0;
    #client_id: string | null = null;
    //TODO(robnagler) registration interface
    #pendingCalls: Map<number, Call> = new Map<number,Call>();
    #socket: WebSocket | null = null;
    #socketRetryBackoff: number = 0;
    #unsentMsgs: Array<any> = new Array<any>;

    constructor(private log: LogService) {
        this.log.info('create websocket');
        this.#socketOpen();
    }

    // Single send and a reply
    call(api_name: string, api_args: any, resultHandler: ResultHandler, apiErrorHandler?: APIErrorHandler) : Call {
        return this.#sendCall(new Call(this, this.log, false, ++this.#call_id, api_name, api_args, resultHandler, apiErrorHandler));
    }

    // not a public interface
    callDestroy(call_id: number) {
        this.#pendingCalls.delete(call_id);
        // unsentMsgs could be deleted, but unlikely
    }

    ngOnDestroy() {
        this.log.info('destroy websocket');
        if (this.#socket) {
            this.#socket.close();
            this.#socket = null;
        }
        this.#clearCalls('ngOnDestroy');
    }

    // not a public interface
    sendUnsubscribe(msg: any) {
        this.#unsentMsgs.push(msg);
        this.#send();
    }

    // Single send and a reply
    subscribe(api_name: string, api_args: any, resultHandler: ResultHandler, apiErrorHandler?: APIErrorHandler) : Call {
        return this.#sendCall(new Call(this, this.log, true, ++this.#call_id, api_name, api_args, resultHandler, apiErrorHandler));
    }

    #authError(error: string) {
        // If there is a protocol error, this will retry forever. That would be a major problem
        // which is not fixable or really detectable. Likely case is the socket closed before auth
        // completed.
        if (this.#socket) {
            this.#socket.close();
        }
        this.#socketOnError(error);
    }

    #authResult(api_result: any) {
        this.#authOK = true;
        this.#socketRetryBackoff = 0;
        this.#send();
    }

    #clearCalls(error: string) {
        const a = [...this.#pendingCalls.values()];
        this.#pendingCalls = new Map<number,Call>();
        this.#unsentMsgs = new Array<any>();
        for (const c of a) {
            c.destroy();
        }
    }

    #findCall(calls: Map<number, Call>, call_id: number) : Call | null {
        const rv = calls.get(call_id);
        if (! rv) {
            return null;
        }
        if (rv.destroyed) {
            // TODO(robnagler) raise error? This should not happen.
            calls.delete(call_id);
            return null;
        }
        return rv;
    }

    #send() {
        if (! this.#socket || this.#unsentMsgs.length <= 0 || ! this.#authOK) {
            return;
        }
        let m = null;
        while (m = this.#unsentMsgs.shift()) {
            this.#sendOne(m);
        }
    };

    #sendCall(call: Call) : Call {
        this.#pendingCalls.set(call.call_id, call);
        this.#unsentMsgs.push(call.msg());
        this.#send();
        return call;
    }

    #sendOne(msg: any) {
        // the latter test is to pacify typescript
        if (! this.#socket) {
            return;
        }
        this.#socket.send(msg);
    }

    #socketOnError(event: any) {
        // close: event.code : short, event.reason : str, wasClean : boolean
        // error: app specific
        this.#socket = null;
        if (this.#socketRetryBackoff <= 0) {
            this.#socketRetryBackoff = 1;
            this.log.error(['WebSocket failed', event]);
            this.#clearCalls(event.wasClean ? 'socket closed' : 'socket error');
        }
        if (this.#socketRetryBackoff < 60) {
            this.#socketRetryBackoff *= 2;
        }
        setTimeout(this.#socketOpen.bind(this), this.#socketRetryBackoff * 1000);
    };

    #socketOnMessage(msg: any) {
        const m = decode(msg) as Msg;
        const c = this.#findCall(this.#pendingCalls, m.call_id);
        if (! c) {
            // happens on unsubscribe
            return;
        }
        if (MSG_KIND_REPLY == m.msg_kind) {
            if (m.api_error!) {
                c.handleError(m.api_error);
            }
            else {
                c.handleResult(m.api_result!);
            }
        }
        else if (MSG_KIND_UNSUBSCRIBE == m.msg_kind) {
            if (c.isSubscription) {
                c.handleResult(null);
            }
            else {
                c.handleError('unsubscribe of non-subscription');
            }

        }
        else {
            c.handleError(`protocol error: invalid msg_kind=${m.msg_kind}`)
        }
    };

    #socketOnOpen(event: Event) {
        // throw new Error("not open");
        this.call(
            AUTH_API_NAME,
            {
                // No token, because any value would have to come from the server,
                // and therefore would be discoverable.
                token: null,
                version: AUTH_API_VERSION,
            },
            this.#authResult.bind(this),
            this.#authError.bind(this),
        )
        const m = this.#unsentMsgs.pop()!;
        this.#sendOne(m);
    };

    #socketOpen() {
        try {
            const s = new WebSocket('/api-v1')
            s.onclose = this.#socketOnError.bind(this);
            s.onerror = this.#socketOnError.bind(this);
            s.onmessage = (event) => {
                this.#socketOnMessage.bind(this);
                event.data.arrayBuffer().then(
                    this.#socketOnMessage.bind(this),
                    (error: Event) => {
                        this.log.error(['arrayBuffer decode error', error, event.data]);
                        this.#socketOnError(event);
                    },
                );
            };
            s.onopen = this.#socketOnOpen.bind(this);
            this.#authOK = false;
            this.#socket = s;
        } catch (err) {
            this.#socketOnError(err);
        }
    };
}
