// Interface to UI API service
//
// Copyright (c) 2024 The Board of Trustees of the Leland Stanford Junior University, through SLAC National Accelerator Laboratory (subject to receipt of any required approvals from the U.S. Dept. of Energy).  All Rights Reserved.
// http://github.com/slaclab/slicops/LICENSE

import { Injectable } from '@angular/core';
import { encode, decode } from '@msgpack/msgpack';
import { LogService } from './log.service';

type ResultHandler = (api_result: any) => void;

type APIErrorHandler = (api_error: string) => void;

type ReplyMsg = {
    api_error: string;
    call_id: number;
    api_result: any;
};

//TODO(robnagler) needs to be generated by server
const AUTH_API_NAME = 'authenticate_connection';

const AUTH_API_VERSION = 658584001;

const MSG_KIND_BASE = 777500;
const MSG_KIND_CALL = 1 + MSG_KIND_BASE;
const MSG_KIND_REPLY = 2 + MSG_KIND_BASE;
const MSG_KIND_SUBSCRIBE = 3 + MSG_KIND_BASE;
const MSG_KIND_UNSUBSCRIBE = 4 + MSG_KIND_BASE;


class Call {
    apiErrorHandler?: APIErrorHandler;
    api_args: any;
    api_name: string;
    call_id: number;
    destroyed: boolean = false;
    isSubscription: boolean;
    resultHandler: ResultHandler;

    constructor(apiService: APIClass, isSubscription: boolean, call_id: number, api_name: string, api_args: any, resultHandler: ResultHandler, apiErrorHandler?: APIErrorHandler) {
        this.apiErrorHandler = apiErrorHandler;
        this.apiService = apiService;
        this.api_name = api_name;
        this.call_id = call_id;
        this.isSubscription = isSubscription;
        this.resultHandler = resultHandler;
        this.api_args;
    }

    destroy() {
        if (this.destroyed) {
            return;
        }
        this.destroyed = true;
        send unsub?
    }

    handleError(api_error: any) {
        // unsub implicit
        log;
        if (this.apiErrorHandler) {
            this.apiErrorHandler(api_error);
        }
        else {
            this.log.dbg(['api_error, calling errorHandler', api_error, this]);
            this.#defaultErrorHandler(api_error);
        }
        this.destroy();
    }

    handleResult(api_result: any) {
        t
        this.resultHandler(api_result);
        if (api_result == null || ! this.isSubscription) {
            this.destroy();
        }
    }

    msg() : any {
        const a = this.api_args;
        this.api_args = null;
        return encode({
            api_args: a,
            api_name: this.api_name,
            call_id: this.call_id,
            msg_kind: this.isSubscription ? MSG_KIND_SUBSCRIBE : MSG_KIND_CALL,
        });
    }

    unsubscribe() {
        if (this.destroyed) {
            return;
        }
        if (! this.isSubscription) {
            throw new Error(`call to api_name=${this.api_name} is not a subscription`);
        }
        this.apiService.sendUnsubscribe(
            encode({
                call_id: this.call_id,
                msg_kind: MSG_KIND_UNSUBSCRIBE,
            }),
        );
        this.destroy();

    }

    #defaultErrorHandler(error: any) {
        this.log.error(['call error', error, call]);
    }
}

@Injectable({
    providedIn: 'root'
})
export class APIService {
    #authOK: boolean = false;
    #call_id: number = 0;
    #client_id: string | null = null;
    //TODO(robnagler) registration interface
    #pendingCalls: Map<number, Call> = new Map<number,Call>();
    #socket: WebSocket | null = null;
    #socketRetryBackoff: number = 0;
    #unsentMsgs: Array<any> = new Array<any>;

    constructor(private log: LogService) {
        this.log.info('create websocket');
        this.#socketOpen();
    }

    // Single send and a reply
    call(api_name: string, api_args: any, resultHandler: ResultHandler, apiErrorHandler?: APIErrorHandler) : Call {
        return this.#sendCall(new Call(this, false, ++this.#call_id, api_name, api_args, resultHandler, apiErrorHandler));
    }

    // not a public interface
    callDestroy(call: Call) {
        self.#pendingCalls.delete(call.call_id);
    }

    ngOnDestroy() {
        this.log.info('destroy websocket');
        if (this.#socket) {
            this.#socket.close();
            this.#socket = null;
        }
        this.#clearCalls('ngOnDestroy');
    }

    // not a public interface
    sendUnsubscribe(msg: any) {
        this.#unsentMsgs.push(msg);
        this.#send();
    }

    // Single send and a reply
    subscribe(api_name: string, api_args: any, resultHandler: ResultHandler, apiErrorHandler?: APIErrorHandler) : Call {
        return this.#sendCall(new Call(this, true, ++this.#call_id, api_name, api_args, resultHandler, apiErrorHandler));
    }

    #authError(error: string) {
        // If there is a protocol error, this will retry forever. That would be a major problem
        // which is not fixable or really detectable. Likely case is the socket closed before auth
        // completed.
        if (this.#socket) {
            this.#socket.close();
        }
        this.#socketOnError(error);
    }

    #authResult(api_result: any) {
        this.#authOK = true;
        this.#socketRetryBackoff = 0;
        this.#send();
    }

    #clearCalls(error: string) {
        const a = [...this.#pendingCalls.values()];
        this.#pendingCalls = new Map<number,Call>();
        this.#unsentMsgs = new Array<any>();
        for (const c of a) {
            c.destroy();
        }
    }

    #findCall(calls: Map<number, Call>, call_id: number) : Call | null {
        const rv = calls.get(call_id);
        if (! rv) {
            return null;
        }
        if (rv.destroyed) {
            // TODO(robnagler) raise error? This should not happen.
            calls.delete(call_id);
            return null;
        }
        return rv;
    }

    #send() {
        if (! this.#socket || this.#unsentMsgs.length <= 0 || ! this.#authOK) {
            return;
        }
        let m = null;
        while (m = this.#unsentMsgs.shift()) {
            this.#sendOne(m);
        }
    };

    #sendCall(call: Call) : Call {
        this.#pendingCalls.set(call.call_id, call);
        this.#unsentMsgs.push(call.msg());
        this.#send();
        return call;
    }

    #sendOne(msg: Call) {
        // the latter test is to pacify typescript
        if (! this.#socket) {
            return;
        }
        this.#socket.send(call.msg());
    }

    #socketOnError(event: any) {
        // close: event.code : short, event.reason : str, wasClean : boolean
        // error: app specific
        this.#socket = null;
        if (this.#socketRetryBackoff <= 0) {
            this.#socketRetryBackoff = 1;
            this.#errorHandler(['WebSocket failed', event]);
            this.#clearCalls(event.wasClean ? 'socket closed' : 'socket error');
        }
        if (this.#socketRetryBackoff < 60) {
            this.#socketRetryBackoff *= 2;
        }
        this.log.dbg(['socketRetryBackoff', this.#socketRetryBackoff]);
        setTimeout(this.#socketOpen.bind(this), this.#socketRetryBackoff * 1000);
    };

    #socketOnMessage(msg: any) {
        const m = decode(msg) as ReplyMsg;
        const c = this.#findCall(this.#pendingCalls, m.call_id);
        if (! c) {
            // happens on unsubscribe
            return;
        }
        if (MSG_KIND_REPLY == m.msg_kind) {
            if (m.api_error) {
                c.handleError(m.api_error);
            }
            else {
                this.log.dbg(['api_result', m.api_result, c.api_name, c.call_id]);
                c.handleResult(m.api_result);
            }
        }
        else if (MSG_KIND_UNSUBSCRIBE == m.msg_kind) {
            if (c.isSubscription) {
                c.handleResult(null);
            }
            else {
                c.handleError('unsubscribe of non-subscription');
            }

        }
    };

    #socketOnOpen(event: Event) {
        // throw new Error("not open");
        this.call(
            AUTH_API_NAME,
            {
                // No token, because any value would have to come from the server,
                // and therefore would be discoverable.
                token: null,
                version: AUTH_API_VERSION,
            },
            this.#authResult.bind(this),
            this.#authError.bind(this),
        )
        const m = this.#unsentMsgs.pop()!;
        this.#sendOne(m);
    };

    #socketOpen() {
        try {
            const s = new WebSocket('/api-v1')
            s.onclose = this.#socketOnError.bind(this);
            s.onerror = this.#socketOnError.bind(this);
            s.onmessage = (event) => {
                this.#socketOnMessage.bind(this);
                event.data.arrayBuffer().then(
                    this.#socketOnMessage.bind(this),
                    (error: Event) => {
                        this.log.error(['arrayBuffer decode error', error, event.data]);
                        this.#socketOnError(event);
                    },
                );
            };
            s.onopen = this.#socketOnOpen.bind(this);
            this.#authOK = false;
            this.#socket = s;
        } catch (err) {
            this.#socketOnError(err);
        }
    };
}
